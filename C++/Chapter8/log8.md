# 8.1 C++内联函数
函数的调用：  
执行到函数调用指令时，  
程序将在函数调用后立即存储该指令的内存地址，  
并将函数参数复制到堆栈，  
跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），  
然后跳回到地址被保存的指令处。  
**内联函数避免这种跳跃的发生，通过占用更多的内存来减少计算开销**

程序员请求将函数作为内联函数时编译器不一定会满足这种要求，它可能认为该函数过大或注意到函数调用了自己（内联函数不能递归），或者有些编译器没有启用或实现这种特性。
<br><br>

# 8.2 引用变量
引用变量的主要用途是用作函数的形参。函数将使用原始数据而不是副本。

必须在声明引用时将其初始化。

左值：  
左值参数是可被引用的数据对象，例如变量、数组元素、结构成员、引用和解除引用的指针。  
非左值包括字面常量（用引号括起的字符串除外，它们由其地址表示）和包含多项的表达式。

形参为引用时，实参类型应与引用参数相匹配，否则C++将生成临时变量，临时变量只在函数调用期间存在。此时的行为类似按值传递。  
创建临时变量的时机：
- 实参的类型正确，但不是左值；
- 实参的类型不正确，但可以转换为正确的类型

使用引用作为形参时应尽可能将其声明为const的原因：
- 使用const可以避免无意中修改数据的编程错误；
- 使用const使函数能够处理const和非const实参，否则只能接受非const实参；
- 使用const引用使函数能够正确生成并使用临时变量。

**一般来说使用引用就是希望实参也能被修改，但是比如对于类对象，有时候只是想利用里面的成员，不想修改里面的内容，就要用const。**

C++11新增了一种右值引用（rvalue reference），这种引用可以指向右值。用&&声明：
```c++
double j = 1.0;
double && jref = 2.0 * j; //not allowed for double &
```

引入引用主要是为了结构和类这样的用户定义类型。

传统返回机制与按值传递类似，通过计算关键字return后面的表达式，将得到的结果返回给调用函数，从概念上来说这个值会被复制到一个临时位置，而调用程序将使用这个值。返回值为引用时效率将会更高。

**将C风格字符串用作string对象引用参数**  
*string类定义了一种从char\*到string的转换功能，这样使得可以使用C风格字符串来初始化string对象。*  
*我们又已知实参类型与引用参数不匹配时，可被转换为引用类型，*  
*这种属性的结果是，如果形参类型为const string &，在调用函数时，使用的实参可以是string对象或C风格字符串，如用括号括起的字符串字面量、以空字符结尾的char数组或指向char的指针变量。*

参数类型选择的指导原则：
- 对于使用传递的值而不做修改的函数
  - 如果数据对象很小，如内置数据类型或小型结构，则按值传递
  - 如果数据对象是数组，则使用指针，这是唯一的选择，并加上const
  - 如果数据对象是较大的结构，则使用const指针或const引用
  - 如果数据对象是类对象，则使用const引用。传递类对象参数的标准方式就是按引用传递
- 对于修改调用函数中数据的函数
  - 如果数据对象是内置数据类型，则使用指针
  - 如果数据对象是数组，则只能使用指针
  - 如果数据对象是结构，则使用引用或指针
  - 如果数据对象是类对象，则使用引用
<br><br>

# 8.3 默认参数
对于带参数列表的函数，必须从右向左添加默认值。  
实参从左到右依次被赋给相应的形参，不可跳过：
```c++
beeps = harpo(3, ,8); //invalid
```
<br><br>

# 8.4 函数重载
函数重载就是一种函数多态。

函数重载的关键是函数的参数列表，也称为函数特征标function signature

编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标
<br><br>

# 8.5 函数模板
```c++
template <typename AnyType>
void Swap(AnyType &a, AnyType &b)
{
    AnyType temp;
    temp = a;
    a = b;
    b = temp;
}
```
上述代码第一行指出，要建立一个模板，并将类型命名为AnyType。关键字template和typename是必需的，除非可以使用class代替typename。另外必须使用尖括号。类型名可以随意起名，一般用T。C++98添加了关键字typename，之前用class。

最终的代码不包含任何模板，只包含了编译器为程序生成的实际函数。

## 显式具体化
**放过自己。**