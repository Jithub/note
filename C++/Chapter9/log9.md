# 9.1 单独编译
头文件中常包含的内容：函数原型、使用#define或const定义的符号常量、结构声明、类声明、模板声明、内联函数
<br><br>

# 9.2 存储持续性、作用域和链接性
C++使用三种（C++11是四种）不同方案来存储数据：
- 自动存储持续性：在函数定义中声明的变量，包括函数参数。C++有2种自动的变量，自动变量和寄存器变量
- 静态存储持续性：在函数外定义的和使用关键字的变量。它们在程序整个运行过程中都存在。C++有3种静态的变量
- 线程存储持续性（C++11）：如果变量是使用关键字thread_local声明的，则其生命周期与所属的线程一样长。
- 动态存储持续性：用new运算符分配的内存将一直存在，知道使用delete。有时被称为自由存储（free store）或堆（heap）。

作用域scope描述了名称在文件（翻译单元）的多大范围可见。  
链接性linkage描述了名称如何在不同单元间共享。链接性为外部的可在文件之间共享，内部的只能由一个文件中的函数共享。自动变量的名称没有链接性。

C++函数的作用域不能是局部的，因为不能在代码块中定义函数，如果函数的作用域为局部，则只对它自己是可见的，不能被其他函数所调用。这样的函数无法允许。

## 自动存储持续性
关键字register最初由C语言引入，建议编译器使用CPU寄存器来存储自动变量，旨在提高访问变量的速度。C++11中这种提示作用也失去了，只是显式地指出变量是自动的。
## 静态持续变量
如果没有显式地初始化静态变量，编译器将把它设置为0。称为零初始化zero-initialize。零初始化和常量表达式的初始化均为静态初始化，即编译时就被初始化。看看下面代码种静态变量的初始化方式：
```c++
#include <cmath>
int x;  //零初始化
int y = 5;  //常量表达式初始化
long z = 13 * 13; //常量表达式初始化
const double pi = 4.0 * atan(1.0); //使用了函数，因此要用动态初始化
int enough = 2 * sizeof(long) + 1; //使用sizeof运算符，也是常量表达式初始化
```

**P310 表9.1 5种变量存储方式**  
**不在任何函数内定义的变量为静态存储持续性，加了static的为内部链接性，不加的为外部链接性。**

C++11新增了关键字constexpr，增加了创建常量表达式的方式。

### 1. 静态持续性、外部链接性
链接性为外部的变量通常简称为外部变量，也称全局变量（相对于局部的自动变量）。

一方面，每个使用外部变量的文件中都必须声明它；另一方面，C++有“单定义规则”One Definition Rule，该规则指出变量只能有一次定义。  
为满足该需求，C++提供两种变量声明。一种是定义声明defining declaration，简称为定义definition，它给变量分配存储空间；另一种是引用声明referencing declaration，简称为声明declaration，它只是引用已有的变量。  
引用声明使用关键字extern，且不进行初始化；否则成为定义，导致分配内存空间：
```c++
double up; //定义
extern int blem; //引用声明
extern char gr = 'z';//定义
```
只需要在一个文件中包含所需外部变量的定义（可以不加extern），其他任何要使用该变量的文件中都要用extern来声明它。

对于局部变量可能与全局变量同名的问题，C++提供作用域解析运算符::，放在变量名前面时，该运算符表示使用变量的全局版本。

### 2. 静态持续性、内部链接性
将static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的。

### 3. 静态持续性、无链接性
将static限定符用于在代码块中的变量。

### 说明符和限定符
有些被称为存储说明符（storage class specifier）或cv-限定符（cv-qualifier）的C++关键字提供了有关存储的信息。

存储说明符：auto（C++11中不再是）、register、static、extern、thread_local（C++11新增）、mutable（用于结构/类成员时，即使结构/类为const，该成员也可被修改）

cv-限定符：const、volatile（用于改善编译器的优化能力）

const全局变量的链接性为内部的。要使其具体有外部链接性，则再在前面加上extern。

### 函数和链接性
C++和C一样不允许在一个函数中定义另一个函数，因此函数的存储持续性都自动为静态的。  
默认情况下函数的链接性为外部的，可以使用static使其变为内部的。

内联函数不受单规则定义的约束，因此可以将其定义放在头文件中。

### 语言链接性
链接程序要求每个不同的函数都有不同的符号名。C中一个名称只对应一个函数，C++中可能对应多个。因此C++编译器执行第8章8.4节最后的名称矫正或名称修饰来生成不同的符号名称，成为C++语言链接（C++ language linking）。

如果C++程序中要使用C库文件中预编译的函数，可以用函数原型要指出要使用的约定：
```c++
extern "C" void spiff(int); //使用C语言链接性
extern void spoff(int); //隐式地使用C++
extern "C++" void spaff(int); //显式地使用C++
```

### 存储方案和动态分配
new/malloc分配的内存被称为动态内存，不受作用域和链接性规则控制。编译器通常使用三块内存：一块用于静态变量（可能再细分），一块用于自动变量，一块用于动态存储。

#### 1.使用new运算符初始化
C++98提供括号，C++11则支持列表初始化。
#### 2.new失败时
最初返回空指针，现在引发异常`std::bad_alloc`
#### 3.new：运算符、函数和替换函数
new和new[]分别调用如下函数：
```c++
void * operator new(std::size_t);
void * operator new[](std::size_t);
```
称为分配函数allocation function。同样有释放函数deallocation function：
```c++
void operator delete(void *);
void operator delete[](void *);
```
下列语句：
```c++
int * pi = new int;
int * pa = new int[40];
delete pi;
```
将被替换为：
```c++
int * pi = new(sizeof(int));
int * pa = new(40 * sizeof(int));
delete(pi);
```
#### 4.定位new运算符
使用new的变体，定位（placement）new运算符，可以指定要使用的位置。程序员可能使用这种特性来设置其内存管理规程、处理需要通过特定地址进行访问的硬件或在特定位置创建对象。

首先需要包含头文件new，然后将new运算符用于提供了所需地址的参数。
```c++
#include <new>
struct chaff
{
    char dross[20];
    int slag;
};
char buffer1[50];
char buffer2[500];
int main()
{
    char *p1, *p2;
    int *p3, *p4;
    p1 = new chaff;   //使用堆内存
    p3 = new int[20]; //使用堆内存
    p2 = new (buffer1) chaff;   //使用变量buffer1来存储
    p4 = new (buffer2) int[20]; //使用变量buffer2来存储
}
```
**就先这样吧**
<br><br>

# 9.3 名称空间
名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。

未被作用域解析运算符修饰的名称称为未限定的名称unqualified name。

using声明使得特定的标识符可用，using编译指令使得整个名称空间可用。

通过别名来简化对名称空间或嵌套名称空间的使用：
```c++
namespace my_very_favorite_things {...};
namespace mvft = my_very_favorite_things;
namespace MEF = myth::elements:fire;
```

对于未命名的名称空间：
```c++
namespace
{
    int ice;
    int bandycoot;
}
```
无法对其使用using编译指令或using声明，即不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称，因此其内部名称具有静态存储连续性，链接性为内部。

**名称空间里的函数也是头文件里写原型，源文件里写定义**

## 名称空间及其前途
一些指导原则：
- 使用在已命名的名称空间中的变量，而不是使用外部全局变量；
- 使用在已命名的名称空间中的变量，而不是使用静态全局变量；
- 如果开发了一个函数库或类库，将其放在一个名称空间中；
- 仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计；
- 不要在头文件中使用using编译指令；
- 导入名称时，首选使用作用域解析运算符或using声明的方法；
- 对于using声明，首先将其作用域设置为局部而不是全局。

头文件名的变化反映了名称空间的使用变化。