# 12.1 动态内存和类
静态类成员的特点：无论创建了多少对象，程序都只创建一个静态类变量副本，即所有对象共享同一个静态成员。

*静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出其所属的类（不必再用关键字static）。如果是整型或枚举型const，则可以在类声明中初始化。*

C++自动提供了如下的特殊成员函数：
- 默认构造函数，如果没有定义构造函数
- 默认析构函数，如果没有定义
- 复制构造函数，如果没有定义
- 赋值运算符，如果没有定义
- 地址运算符，如果没有定义

## 复制构造函数
复制构造函数用于将一个对象复制到新建的对象中。用于初始化过程（包括按值传递参数），而不是常规的赋值过程。函数原型通常为  
```c++
Class_name(const Class_name &);
```
它接受一个指向类对象的常量引用作为参数。

何时调用：新建一个对象并将其初始化为同类现有对象时。如下：
```c++
Stock ditto(motto);
Stock metoo = motto;
Stock also = Stock(metoo);
Stock pStock = new Stock(also);
```
每当程序生成了对象副本（函数按值传递对象或者函数返回对象）时，编译器都将使用复制构造函数。

有何功能：逐个复制非静态成员（成员复制也成为浅复制/浅拷贝），复制的是成员的值。静态成员不受影响。  
*因此，如果类中包含静态数据成员且其值将在新对象被创建时变化，则应该提供一个显式的复制构造函数。*

上面提到的复制非静态成员为浅拷贝，如果成员是指针，则将复制指针的值，会有问题。  
*所以，如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据而不是指针。*

**还有个赋值运算符，看不下去了。。。**
<br>

# 12.2 改进后的新String类
*C++98中字面值0有两个含义：可以表示数字值零，也可以表示空指针。有些使用`(void*)0`有些使用`NULL`，C++11提供新关键字`nullptr`。* **再看一次<https://blog.csdn.net/qq_38410730/article/details/105183769>**

静态类成员函数与静态数据成员有类似之处。
- 不能通过对象调用静态成员函数，后者甚至不能用this指针。如果静态成员函数是在公有部分声明，可以使用类名+作用域解析运算符来调用。
- 静态成员函数不与特定对象关联，因此只能使用静态数据成员。

**P441页清单12.4 12.5给出了功能较为完整的String类的实现。**
<br><br>

# 12.3 在构造函数中使用new时应注意的事项
- 构造中有new，则析构中应有delete；
- new和delete必须相互兼容。new对应delete，new[]对应delete[]；
- 如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。然而可以在一个里面使用new初始化指针，在另一个里将指针初始化为空，因为delete可以用于空指针；
- 应定义一个复制构造函数，实现深拷贝的对象初始化；
- 应定义一个赋值运算符，实现深拷贝的对象复制；
<br><br>

# 12.4 有关返回对象的说明
**...**
<br><br>

# 12.5 使用指向对象的指针
使用对象指针时应注意的：
- 使用常规表示来声明指向对象的指针：
```c++
String * glamour;
```
- 可以将指针初始化为指向已有的对象：
```c++
String * first = &saying[0];
```
- 可以使用new来初始化指针，这将创建一个新的对象：
```c++
String * favorite = new String(saying[choice]);
```
- 对类使用new将调用相应的类构造函数来初始化对象：
```c++
String * gleep = new String; // invokes default constructor
String * glop = new String("my"); //invokes the String(const char *) constructor
String * favorite = new String(saying[choice]); //invokes the String(const String &) constructor
```
- 可以使用->运算符通过指针访问类方法
- 可以对对象指针应用解除引用运算符*来获得对象

**后面两节还是要好好看一下的**
<br><br>

# 12.6 复习各种技术
<br><br>

# 12.7 队列模拟
*嵌套结构：在类声明中声明的结构、类或者枚举被称为是嵌套在类中，作用域为整个类。这种声明不会创建数据对象，只是指定了可以在类中使用的类型。如果声明在私有部分进行，则只能在这个类中使用该类型；如果是在公有部分，则可以在类外通过Queue::Node的形式声明Node类型的变量。*

对于const成员变量，可以初始化，但不能赋值。而从概念上来说，调用构造函数时，对象将在构造函数的花括号中的代码执行前被创建。因此要使用成员初始化列表提前初始化。  
成员初始化列表：**只有构造函数**才可以使用这种语法。
```c++
Queue::Queue(int qs): qsize(qs), front(NULL), rear(NULL), items(0)
{
}
```
对于非静态const成员和被声明为引用的类成员，必须使用这种语法。对于本身就是类对象的成员来说，使用成员初始化列表的效率更高。初始化顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关。

类内初始化：
```c++
class Classy
{
    int mem1 = 10;
}
```
与使用成员初始化列表等价，但会被后者覆盖。

**剩下的队列实现有空也可以看看**