# 13.1 一个简单的基类
派生类不能直接访问基类的私有成员，只能通过基类方法进行访问。具体地说，派生类构造函数必须使用基类的构造函数。

创建派生类对象时，首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数前被创建。C++使用成员初始化列表来完成该工作.

派生类的构造函数总是调用基类的构造函数，派生类对象过期时，首先调用派生类析构函数，然后调用基类析构函数。

派生类可以使用基类的方法，条件是方法不是私有的。

基类指针（引用）可以在不进行显式类型转换的情况下指向（引用）派生类对象，反过来不行。当然基类指针或引用只能调用基类方法。  
上述关系使得很多地方可以用基类的写法来兼容派生类：
- 函数参数使用基类的引用或指针，则实参便可以是派生类
- 可以用派生类来初始化基类，应该是在这个过程中调用了基类的隐式复制构造函数，而隐式复制构造函数就是用的基类引用作为形参
- 也可以用派生类对象给基类对象赋值，会使用隐式重载赋值运算符。反过来不行。

**应该用invoke来表示函数调用**
<br><br>

# 13.2 继承：is-a关系
共有继承建立一种 is-a 的关系，即得到的派生类 is-a-kind-of 基类。
<br><br>

# 13.3 多态共有继承
